#include <iostream>
#include <ut>

#include "kira/Vecteur.h"

using namespace kira;

static_assert(std::is_same_v<PromotedType<int, int>::type, int>);
static_assert(std::is_same_v<PromotedType<float, float>::type, float>);
static_assert(std::is_same_v<PromotedType<float, int>::type, float>);
static_assert(std::is_same_v<PromotedType<int, float>::type, float>);
static_assert(std::is_same_v<PromotedType<Vecteur<int, 1>, float>::type, float>);
static_assert(std::is_same_v<PromotedType<float, Vecteur<int, 1>>::type, float>);
static_assert(std::is_same_v<PromotedType<Vecteur<int, 1>, Vecteur<float, 1>>::type, float>);
static_assert(std::is_same_v<PromotedType<Vecteur<float, 1>, Vecteur<int, 1>>::type, float>);

static_assert(is_safely_convertible<short, int>);
static_assert(is_safely_convertible<char, int>);
static_assert(is_safely_convertible<int, long>);
static_assert(is_safely_convertible<long, long long>);
static_assert(!is_safely_convertible<long long, int>);
static_assert(!is_safely_convertible<int, short>);

static_assert(is_safely_convertible<unsigned short, unsigned int>);
static_assert(is_safely_convertible<unsigned int, unsigned long>);
static_assert(is_safely_convertible<unsigned long, unsigned long long>);
static_assert(!is_safely_convertible<unsigned long long, unsigned int>);

static_assert(is_safely_convertible<int, unsigned int>);
static_assert(!is_safely_convertible<unsigned int, int>);
static_assert(is_safely_convertible<unsigned int, long long>);
static_assert(!is_safely_convertible<long long, unsigned int>);

static_assert(is_safely_convertible<float, double>);
static_assert(is_safely_convertible<float, long double>);
static_assert(is_safely_convertible<double, long double>);
static_assert(!is_safely_convertible<double, float>);
static_assert(!is_safely_convertible<long double, double>);

static_assert(is_safely_convertible<int, float>);
static_assert(is_safely_convertible<long, double>);
static_assert(is_safely_convertible<long long, long double>);

static_assert(!is_safely_convertible<float, int>);
static_assert(!is_safely_convertible<double, long>);
static_assert(!is_safely_convertible<long double, long long>);

static_assert(is_safely_convertible<bool, int>);
static_assert(is_safely_convertible<bool, float>);
static_assert(!is_safely_convertible<int, bool>);
static_assert(!is_safely_convertible<float, bool>);


// NOTE(krr): great tests generated by Claude
namespace {
ut::suite vecteur = [] {
    using namespace ut;

    "zero_ctor"_test = [] {
        kira::Vecteur<int, 3> x{0};
        expect(0_i == x[0]);
        expect(0_i == x[1]);
        expect(0_i == x[2]);
    };

    "one_ctor"_test = [] {
        kira::Vecteur<int, 3> x{1};
        expect(1_i == x[0]);
        expect(1_i == x[1]);
        expect(1_i == x[2]);
    };

    "arb_ctor"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        expect(1_i == x[0]);
        expect(2_i == x[1]);
        expect(3_i == x[2]);
    };

    "xyz"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        expect(1_i == x.x());
        expect(2_i == x.y());
        expect(3_i == x.z());
    };

    "add"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        kira::Vecteur<int, 3> y{3, 2, 1};
        auto z = x + y;

        expect(z[0] == 4_i);
        expect(z[1] == 4_i);
        expect(z[2] == 4_i);

        auto w1 = x + 1;
        expect(w1.size() == 3_ul);
        expect(w1.x() == 2_i);
        expect(w1.y() == 3_i);
        expect(w1.z() == 4_i);

        auto w2 = 1 + x;
        expect(w2.size() == 3_ul);
        expect(w2.x() == 2_i);
        expect(w2.y() == 3_i);
        expect(w2.z() == 4_i);
    };

    "mul"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        kira::Vecteur<int, 3> y{2, 3, 4};

        auto z = x * y;
        expect(z[0] == 2_i);
        expect(z[1] == 6_i);
        expect(z[2] == 12_i);

        auto w1 = 2 * x;
        expect(w1.size() == 3_ul);
        expect(w1.x() == 2_i);
        expect(w1.y() == 4_i);
        expect(w1.z() == 6_i);

        auto w2 = x * 3;
        expect(w2.size() == 3_ul);
        expect(w2.x() == 3_i);
        expect(w2.y() == 6_i);
        expect(w2.z() == 9_i);
    };

    "mul_fp"_test = [] {
        kira::Vecteur<double, 3> x{1.1, 2.2, 3.3};
        kira::Vecteur<double, 3> y{2.5, 3.5, 4.5};

        auto z = x * y;
        expect((z[0] == 2.75_d)(.01)) << "z[0] should be close to 2.75";
        expect((z[1] == 7.70_d)(.01)) << "z[1] should be close to 7.70";
        expect((z[2] == 14.85_d)(.01)) << "z[2] should be close to 14.85";

        auto w1 = 2.5 * x;
        expect(w1.size() == 3_ul);
        expect((w1.x() == 2.75_d)(.01)) << "w1.x() should be close to 2.75";
        expect((w1.y() == 5.50_d)(.01)) << "w1.y() should be close to 5.50";
        expect((w1.z() == 8.25_d)(.01)) << "w1.z() should be close to 8.25";

        auto w2 = x * 3.5;
        expect(w2.size() == 3_ul);
        expect((w2.x() == 3.85_d)(.01)) << "w2.x() should be close to 3.85";
        expect((w2.y() == 7.70_d)(.01)) << "w2.y() should be close to 7.70";
        expect((w2.z() == 11.55_d)(.01)) << "w2.z() should be close to 11.55";
    };

    "div"_test = [] {
        kira::Vecteur<int, 3> x{6, 12, 18};
        kira::Vecteur<int, 3> y{2, 3, 4};

        auto z = x / y;
        expect(z[0] == 3_i);
        expect(z[1] == 4_i);
        expect(z[2] == 4_i);

        auto w1 = x / 2;
        expect(w1.size() == 3_ul);
        expect(w1.x() == 3_i);
        expect(w1.y() == 6_i);
        expect(w1.z() == 9_i);

        auto w2 = 36 / x;
        expect(w2.size() == 3_ul);
        expect(w2.x() == 6_i);
        expect(w2.y() == 3_i);
        expect(w2.z() == 2_i);
    };

    "div_fp"_test = [] {
        kira::Vecteur<double, 3> x{6.0, 12.0, 18.0};
        kira::Vecteur<double, 3> y{2.0, 3.0, 4.0};

        auto z = x / y;
        expect((z[0] == 3.0_d)(.01)) << "z[0] should be close to 3.0";
        expect((z[1] == 4.0_d)(.01)) << "z[1] should be close to 4.0";
        expect((z[2] == 4.5_d)(.01)) << "z[2] should be close to 4.5";

        auto w1 = x / 2.0;
        expect(w1.size() == 3_ul);
        expect((w1.x() == 3.0_d)(.01)) << "w1.x() should be close to 3.0";
        expect((w1.y() == 6.0_d)(.01)) << "w1.y() should be close to 6.0";
        expect((w1.z() == 9.0_d)(.01)) << "w1.z() should be close to 9.0";

        auto w2 = 36.0 / x;
        expect(w2.size() == 3_ul);
        expect((w2.x() == 6.0_d)(.01)) << "w2.x() should be close to 6.0";
        expect((w2.y() == 3.0_d)(.01)) << "w2.y() should be close to 3.0";
        expect((w2.z() == 2.0_d)(.01)) << "w2.z() should be close to 2.0";
    };

    "max"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        kira::Vecteur<int, 3> y{6, 5, 2};

        auto z = x.max(y);
        expect(z[0] == 6_i);
        expect(z[1] == 5_i);
        expect(z[2] == 3_i);
    };

    "max_scalar"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};

        auto z = x.max(2);
        expect(z[0] == 2_i);
        expect(z[1] == 2_i);
        expect(z[2] == 3_i);
    };

    "min"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        kira::Vecteur<int, 3> y{6, 5, 2};

        auto z = x.min(y);
        expect(z[0] == 1_i);
        expect(z[1] == 2_i);
        expect(z[2] == 2_i);
    };

    "min_scalar"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};

        auto z = x.min(2);
        expect(z[0] == 1_i);
        expect(z[1] == 2_i);
        expect(z[2] == 2_i);
    };

    "dot_product"_test = [] {
        kira::Vecteur<int, 3> ix{1, 2, 3};
        kira::Vecteur<int, 3> iy{3, 2, 1};

        auto z = ix.dot(iy);
        expect(z == 10_i);
    };

    "dot_product_fp"_test = [] {
        kira::Vecteur<float, 3> fx{1.5f, 2.5f, 3.5f};
        kira::Vecteur<float, 3> fy{3.0f, 2.0f, 1.0f};

        auto z = fx.dot(fy);
        expect((z == 13.0_f)(.01)) << "Dot product should be close to 13.0";
    };

    "eq"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        kira::Vecteur<int, 3> y{1, 2, 3};
        kira::Vecteur<int, 3> z{3, 2, 1};

        expect(x.eq(y) == true_b);
        expect((x == y) == true_b);
        expect(not(x != y) == true_b);
        expect(not x.eq(z) == true_b);
        expect(not(x == z) == true_b);
        expect(x != z == true_b);
    };

    "near"_test = [] {
        float const epsilon = 1e-4F;

        kira::Vecteur<float, 3> v1{1.0f, 2.0f, 3.0f};
        kira::Vecteur<float, 3> v2{1.0f, 2.0f, 3.0f};
        expect(v1.near(v2, epsilon) == true_b);

        kira::Vecteur<float, 3> v3{1.0f, 2.0f, 3.0f + epsilon * 0.9f};
        expect(v1.near(v3, epsilon) == true_b);

        kira::Vecteur<float, 3> v4{1.0f, 2.0f, 3.0f + epsilon * 1.1f};
        expect(not v1.near(v4, epsilon) == true_b);
    };

    "hsum"_test = [] {
        kira::Vecteur<int, 3> v1{1, 2, 3};
        expect(v1.hsum() == 6_i);

        kira::Vecteur<float, 4> v2{1.0f, 2.0f, 3.0f, 4.0f};
        expect((v2.hsum() == 10.0_f)(.01)) << "Sum should be close to 10.0";
    };

    "hprod"_test = [] {
        kira::Vecteur<int, 3> v1{1, 2, 3};
        expect(v1.hprod() == 6_i);

        kira::Vecteur<float, 4> v2{1.0f, 2.0f, 3.0f, 4.0f};
        expect((v2.hprod() == 24.0_f)(.01)) << "Product should be close to 24.0";
    };

    "hmax"_test = [] {
        kira::Vecteur<int, 3> v1{1, 3, 2};
        expect(v1.hmax() == 3_i);

        kira::Vecteur<float, 4> v2{1.0f, 4.0f, 3.0f, 2.0f};
        expect((v2.hmax() == 4.0_f)(.01)) << "Max should be close to 4.0";
    };

    "hmin"_test = [] {
        kira::Vecteur<int, 3> v1{1, 3, 2};
        expect(v1.hmin() == 1_i);

        kira::Vecteur<float, 4> v2{1.0f, 4.0f, 3.0f, 2.0f};
        expect((v2.hmin() == 1.0_f)(.01)) << "Min should be close to 1.0";
    };

    "negate"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        auto y = -x;

        expect(y[0] == -1_i);
        expect(y[1] == -2_i);
        expect(y[2] == -3_i);
    };

    "sqr"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};
        auto y = x.sqr();

        expect(y[0] == 1_i);
        expect(y[1] == 4_i);
        expect(y[2] == 9_i);
    };

    "negate_fp"_test = [] {
        kira::Vecteur<float, 3> x{1.0f, 2.0f, 3.0f};
        auto y = -x;

        expect((y[0] == -1.0_f)(.0001)) << "y[0] should be close to -1.0";
        expect((y[1] == -2.0_f)(.0001)) << "y[1] should be close to -2.0";
        expect((y[2] == -3.0_f)(.0001)) << "y[2] should be close to -3.0";
    };

    "sqr_fp"_test = [] {
        kira::Vecteur<float, 3> x{-1.0f, -2.0f, -3.0f};
        auto y = x.sqr();

        expect((y[0] == 1.0_f)(.0001)) << "y[0] should be close to 1.0";
        expect((y[1] == 4.0_f)(.0001)) << "y[1] should be close to 4.0";
        expect((y[2] == 9.0_f)(.0001)) << "y[2] should be close to 9.0";
    };

    "hsum_hprod_with_zero"_test = [] {
        kira::Vecteur<int, 3> v1{0, 1, 2};
        expect(v1.hsum() == 3_i);
        expect(v1.hprod() == 0_i);

        kira::Vecteur<float, 4> v2{0.0f, 1.0f, 2.0f, 3.0f};
        expect((v2.hsum() == 6.0_f)(.0001)) << "Sum should be close to 6.0";
        expect((v2.hprod() == 0.0_f)(.0001)) << "Product should be close to 0.0";
    };

    "hmax_hmin_with_equal_elements"_test = [] {
        kira::Vecteur<int, 3> v1{2, 2, 2};
        expect(v1.hmax() == 2_i);
        expect(v1.hmin() == 2_i);

        kira::Vecteur<float, 4> v2{1.5f, 1.5f, 1.5f, 1.5f};
        expect((v2.hmax() == 1.5_f)(.0001)) << "Max should be close to 1.5";
        expect((v2.hmin() == 1.5_f)(.0001)) << "Min should be close to 1.5";
    };

    "hsum_hprod_with_negative_values"_test = [] {
        kira::Vecteur<int, 3> v1{-1, 2, -3};
        expect(v1.hsum() == -2_i);
        expect(v1.hprod() == 6_i);

        kira::Vecteur<float, 4> v2{-1.0f, 2.0f, -3.0f, 4.0f};
        expect((v2.hsum() == 2.0_f)(.0001)) << "Sum should be close to 2.0";
        expect((v2.hprod() == 24.0_f)(.0001)) << "Product should be close to 24.0";
    };

    "to_span"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};

        auto span = x.to_span();
        expect(span.size() == 3_ul);
        expect(span[0] == 1_i);
        expect(span[1] == 2_i);
        expect(span[2] == 3_i);

        span[1] = 5;
        expect(x[1] == 5_i);

        auto const &constX = x;
        auto constSpan = constX.to_span();
        expect(constSpan.size() == 3_ul);
        expect(constSpan[0] == 1_i);
        expect(constSpan[1] == 5_i);
        expect(constSpan[2] == 3_i);
    };

    "to_array"_test = [] {
        kira::Vecteur<int, 3> x{1, 2, 3};

        auto arr = x.to_array();
        expect(arr.size() == 3_ul);
        expect(arr[0] == 1_i);
        expect(arr[1] == 2_i);
        expect(arr[2] == 3_i);

        arr[1] = 5;
        expect(x[1] == 2_i);
    };
};
} // namespace
